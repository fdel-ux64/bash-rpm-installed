#!/bin/bash

# rpm-installed ‚Äî List installed RPM packages by install date with caching

CACHE_FILE="${XDG_CACHE_HOME:-$HOME/.cache}/rpm_installed_cache"

rpm-installed() {
	# Convert first argument to lowercase for case-insensitive comparison
	local arg="${1:-}"
	[[ -n "$arg" ]] && arg=$(echo "$arg" | tr '[:upper:]' '[:lower:]')

	# ---- Distro check ----
	if ! command -v rpm &>/dev/null; then
		echo " ‚ùå This function requires RPM package manager"
		echo "   Current system does not appear to be RPM-based"
		return 1
	fi

	# ---- Refresh cache ----
	if [[ "$arg" == "--refresh" ]]; then
		rm -f "$CACHE_FILE"
		echo " ‚ôªÔ∏è Cache cleared and will be rebuilt on next command."
		return 0
	fi

	# ---- Help ----

__rpm_installed_help() {
	cat <<-'EOF'
	rpm-installed ‚Äî list installed RPM packages by install date

	USAGE:
	  rpm-installed [OPTION]
	  rpm-installed since DATE [until DATE]
	  rpm-installed count [OPTION] (including 'since ‚Ä¶ until ‚Ä¶')
	  rpm-installed --refresh  # rebuild cache

	OPTIONS:
	  today        Packages installed today
	  yesterday    Packages installed yesterday
	  last-week    Packages installed in the last 7 days
	  this-month   Packages installed this calendar month
	  last-month   Packages installed in the previous calendar month

	ALIASES:
	  td  ‚Üí today
	  yd  ‚Üí yesterday
	  lw  ‚Üí last-week
	  tm  ‚Üí this-month
	  lm  ‚Üí last-month

	COUNT / STATS:
	  rpm-installed count today
	  rpm-installed count last-week
	  rpm-installed count per-day
	  rpm-installed count per-week
	  rpm-installed count since DATE [until DATE]
	EOF
}


	if [[ "$arg" == "-h" || "$arg" == "--help" ]]; then
		__rpm_installed_help
		return 0
	fi

	# ---- Alias normalization ----
	case "$arg" in
	td) arg="today" ;;
	yd) arg="yesterday" ;;
	lw) arg="last-week" ;;
	tm) arg="this-month" ;;
	lm) arg="last-month" ;;
	esac

	# ---- Heading ----
	local heading=""
	case "$arg" in
	today) heading="today" ;;
	yesterday) heading="yesterday" ;;
	last-week) heading="in the last week" ;;
	this-month) heading="this month" ;;
	last-month) heading="last month" ;;
	esac

	# ---- Backend helper ----
	__instlist_rpm() {
		rpm -qa --qf ' %{INSTALLTIME} (%{INSTALLTIME:date}): %{NAME}-%{VERSION}-%{RELEASE}.%{ARCH}\n'
	}

	# ---- Caching ----
	if [[ ! -f "$CACHE_FILE" ]]; then
		mkdir -p "$(dirname "$CACHE_FILE")"
		__instlist_rpm >"$CACHE_FILE"
	fi

	# ---- Count / Stats mode & custom ranges ----
	local count_mode=0
	local since_epoch=""
	local until_epoch=""

	# Convert second argument to lowercase as well for count/stats
	local arg2="${2:-}"
	[[ -n "$arg2" ]] && arg2=$(echo "$arg2" | tr '[:upper:]' '[:lower:]')

	if [[ "$arg" == "count" || "$arg" == "stats" ]]; then
		count_mode=1
		arg="$arg2"
	fi

	# ---- Detect since/until ----
	for ((i = 1; i <= $#; i++)); do
		local token="${!i}"
		[[ -n "$token" ]] && token=$(echo "$token" | tr '[:upper:]' '[:lower:]')
		
		if [[ "$token" == "since" ]]; then
			((idx = i + 1))
			since_epoch=$(LC_ALL=en_US.UTF-8 date -d "${!idx} 00:00" +%s 2>/dev/null)
			if [[ -z "$since_epoch" ]]; then
				echo " ‚ùå Invalid date: ${!idx}"
				echo "   Expected a format understood by 'date -d' (e.g. YYYY-MM-DD)"
				echo
				__rpm_installed_help
				return 1
			fi
		elif [[ "$token" == "until" ]]; then
			((idx = i + 1))
			until_epoch=$(LC_ALL=en_US.UTF-8 date -d "${!idx} 00:00" +%s 2>/dev/null)
			if [[ -z "$until_epoch" ]]; then
				echo " ‚ùå Invalid date: ${!idx}"
				echo "   Expected a format understood by 'date -d' (e.g. YYYY-MM-DD)"
				echo
				__rpm_installed_help
				return 1
			fi
		fi
	done

	# ---- Time boundaries ----
	local today_start=$(LC_ALL=en_US.UTF-8 date -d 'today 00:00' +%s)
	local tomorrow_start=$(LC_ALL=en_US.UTF-8 date -d 'tomorrow 00:00' +%s)
	local yesterday_start=$(LC_ALL=en_US.UTF-8 date -d 'yesterday 00:00' +%s)
	local last_week_start=$(LC_ALL=en_US.UTF-8 date -d '7 days ago 00:00' +%s)
	local this_month_start=$(LC_ALL=en_US.UTF-8 date -d "$(date +%Y-%m-01)" +%s)
	local last_month_start=$(LC_ALL=en_US.UTF-8 date -d "$(date +%Y-%m-01) -1 month" +%s)

	# ---- Helper function to display with formatting ----
	__display_packages() {
		local title="$1"
		shift
		local -a packages=("$@")
		local pkg_count=${#packages[@]}

		if [[ -n "$title" ]]; then
			echo -e "\n     üì¶ List of installed package(s): $title"
			echo "     ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
			echo
		fi

		for pkg in "${packages[@]}"; do
			echo "$pkg"
		done

		if [[ -n "$title" ]]; then
			echo -e "\n ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
			echo -e " üî¢ Total number of package(s): $pkg_count\n"
		fi
	}

	# ---- Execute with caching for since/until ----
	if [[ -n "$since_epoch" ]]; then
		if [[ $count_mode -eq 1 ]]; then
			if [[ -n "$until_epoch" ]]; then
				awk -v s="$since_epoch" -v e="$until_epoch" '{if($1>=s && $1<e) count[strftime("%Y-%m-%d",$1)]++} END{for(d in count) printf "%s  %d\n", d, count[d]}' "$CACHE_FILE" | sort
			else
				awk -v s="$since_epoch" '{if($1>=s) count[strftime("%Y-%m-%d",$1)]++} END{for(d in count) printf "%s  %d\n", d, count[d]}' "$CACHE_FILE" | sort
			fi
		else
			local custom_heading="since $(LC_ALL=en_US.UTF-8 date -d "@$since_epoch" +%Y-%m-%d)"
			if [[ -n "$until_epoch" ]]; then
				custom_heading="$custom_heading until $(LC_ALL=en_US.UTF-8 date -d "@$until_epoch" +%Y-%m-%d)"
				mapfile -t result < <(awk -v s="$since_epoch" -v e="$until_epoch" '$1>=s && $1<e' "$CACHE_FILE" | sort -n)
				__display_packages "$custom_heading" "${result[@]}"
			else
				mapfile -t result < <(awk -v s="$since_epoch" '$1>=s' "$CACHE_FILE" | sort -n)
				__display_packages "$custom_heading" "${result[@]}"
			fi
		fi
		return
	fi

	# ---- Predefined ranges & counts ----
	case "$arg" in
	'')
		if [[ $count_mode -eq 1 ]]; then
			awk '{count[strftime("%Y-%m-%d",$1)]++} END{for(d in count) printf "%s  %d\n", d, count[d]}' "$CACHE_FILE" | sort
		else
			mapfile -t result < <(sort -n "$CACHE_FILE")
			__display_packages "all time" "${result[@]}"
		fi
		;;

	today)
		if [[ $count_mode -eq 1 ]]; then
			awk -v s="$today_start" -v e="$tomorrow_start" '$1>=s && $1<e {count[strftime("%Y-%m-%d",$1)]++} END{for(d in count) printf "%s  %d\n", d, count[d]}' "$CACHE_FILE" | sort
		else
			mapfile -t result < <(awk -v s="$today_start" -v e="$tomorrow_start" '$1>=s && $1<e' "$CACHE_FILE" | sort -n)
			__display_packages "$heading" "${result[@]}"
		fi
		;;

	yesterday)
		if [[ $count_mode -eq 1 ]]; then
			awk -v s="$yesterday_start" -v e="$today_start" '$1>=s && $1<e {count[strftime("%Y-%m-%d",$1)]++} END{for(d in count) printf "%s  %d\n", d, count[d]}' "$CACHE_FILE" | sort
		else
			mapfile -t result < <(awk -v s="$yesterday_start" -v e="$today_start" '$1>=s && $1<e' "$CACHE_FILE" | sort -n)
			__display_packages "$heading" "${result[@]}"
		fi
		;;

	last-week)
		if [[ $count_mode -eq 1 ]]; then
			awk -v s="$last_week_start" '$1>=s {count[strftime("%Y-%m-%d",$1)]++} END{for(d in count) printf "%s  %d\n", d, count[d]}' "$CACHE_FILE" | sort
		else
			mapfile -t result < <(awk -v s="$last_week_start" '$1>=s' "$CACHE_FILE" | sort -n)
			__display_packages "$heading" "${result[@]}"
		fi
		;;

	this-month)
		if [[ $count_mode -eq 1 ]]; then
			awk -v s="$this_month_start" '$1>=s {count[strftime("%Y-%m-%d",$1)]++} END{for(d in count) printf "%s  %d\n", d, count[d]}' "$CACHE_FILE" | sort
		else
			mapfile -t result < <(awk -v s="$this_month_start" '$1>=s' "$CACHE_FILE" | sort -n)
			__display_packages "$heading" "${result[@]}"
		fi
		;;

	last-month)
		if [[ $count_mode -eq 1 ]]; then
			awk -v s="$last_month_start" -v e="$this_month_start" '$1>=s && $1<e {count[strftime("%Y-%m-%d",$1)]++} END{for(d in count) printf "%s  %d\n", d, count[d]}' "$CACHE_FILE" | sort
		else
			mapfile -t result < <(awk -v s="$last_month_start" -v e="$this_month_start" '$1>=s && $1<e' "$CACHE_FILE" | sort -n)
			__display_packages "$heading" "${result[@]}"
		fi
		;;

	per-day)
		awk '{count[strftime("%Y-%m-%d",$1)]++} END{for(d in count) printf "%s  %d\n", d, count[d]}' "$CACHE_FILE" | sort
		;;

	per-week)
		awk '{count[strftime("%Y-W%V",$1)]++} END{for(w in count) printf "%s  %d\n", w, count[w]}' "$CACHE_FILE" | sort
		;;

	*)
		echo " ‚ùå Invalid option: '$arg'"
		echo
		__rpm_installed_help
		return 1
		;;
	esac
}

# If script is executed directly (not sourced), run the function
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
	rpm-installed "$@"
fi
