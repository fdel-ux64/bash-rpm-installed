#!/bin/bash

# rpm-installed — List installed RPM packages by install date with caching

CACHE_FILE="${XDG_CACHE_HOME:-$HOME/.cache}/rpm_installed_cache"

rpm-installed() {
    local arg="${1:-}"

    # ---- Refresh cache ----
    if [[ "$arg" == "--refresh" ]]; then
        rm -f "$CACHE_FILE"
        echo "♻️ Cache cleared and will be rebuilt on next command."
        return 0
    fi

    # ---- Help flag ----
    if [[ "$arg" == "-h" || "$arg" == "--help" ]]; then
        cat <<'EOF'
rpm-installed — list installed RPM packages by install date

USAGE:
  rpm-installed [OPTION]
  rpm-installed since DATE [until DATE]
  rpm-installed count [OPTION] (including 'since … until …')
  rpm-installed --refresh  # rebuild cache

OPTIONS:
  today        Packages installed today
  yesterday    Packages installed yesterday
  last-week    Packages installed in the last 7 days
  this-month   Packages installed this calendar month
  last-month   Packages installed in the previous calendar month

ALIASES:
  td  → today
  yd  → yesterday
  lw  → last-week
  tm  → this-month
  lm  → last-month

COUNT / STATS:
  rpm-installed count today
  rpm-installed count last-week
  rpm-installed count per-day
  rpm-installed count per-week
  rpm-installed count since DATE [until DATE]
EOF
        return 0
    fi

    # ---- Alias normalization ----
    case "$arg" in
        td) arg="today" ;;
        yd) arg="yesterday" ;;
        lw) arg="last-week" ;;
        tm) arg="this-month" ;;
        lm) arg="last-month" ;;
    esac

    # ---- Backend helper ----
    __instlist_rpm() {
        rpm -qa --qf '%{INSTALLTIME} (%{INSTALLTIME:date}): %{NAME}-%{VERSION}-%{RELEASE}.%{ARCH}\n'
    }

    # ---- Caching ----
    if [[ ! -f "$CACHE_FILE" ]]; then
        __instlist_rpm > "$CACHE_FILE"
    fi

    # ---- Count / Stats mode & custom ranges ----
    local count_mode=0
    local since_epoch=""
    local until_epoch=""

    if [[ -n "$arg" ]]; then
        if [[ "$arg" == "count" || "$arg" == "stats" ]]; then
            count_mode=1
            arg="${2:-}"
        fi
    fi

    # ---- Detect since/until ----
    for ((i=1; i<=$#; i++)); do
        if [[ "${!i}" == "since" ]]; then
            ((idx=i+1))
            since_epoch=$(date -d "${!idx} 00:00" +%s 2>/dev/null)
            if [[ -z "$since_epoch" ]]; then
                echo "❌ Invalid date: ${!idx}"
                return 1
            fi
        elif [[ "${!i}" == "until" ]]; then
            ((idx=i+1))
            until_epoch=$(date -d "${!idx} 00:00" +%s 2>/dev/null)
            if [[ -z "$until_epoch" ]]; then
                echo "❌ Invalid date: ${!idx}"
                return 1
            fi
        fi
    done

    # ---- Time boundaries ----
    local today_start=$(date -d 'today 00:00' +%s)
    local tomorrow_start=$(date -d 'tomorrow 00:00' +%s)
    local yesterday_start=$(date -d 'yesterday 00:00' +%s)
    local last_week_start=$(date -d '7 days ago 00:00' +%s)
    local this_month_start=$(date -d "$(date +%Y-%m-01)" +%s)
    local last_month_start=$(date -d "$(date +%Y-%m-01) -1 month" +%s)

    # ---- Execute with caching for since/until ----
    if [[ -n "$since_epoch" ]]; then
        if [[ $count_mode -eq 1 ]]; then
            if [[ -n "$until_epoch" ]]; then
                awk -v s="$since_epoch" -v e="$until_epoch" '{if($1>=s && $1<e) count[strftime("%Y-%m-%d",$1)]++} END{for(d in count) printf "%s  %d\n", d, count[d]}' "$CACHE_FILE" | sort
            else
                awk -v s="$since_epoch" '{if($1>=s) count[strftime("%Y-%m-%d",$1)]++} END{for(d in count) printf "%s  %d\n", d, count[d]}' "$CACHE_FILE" | sort
            fi
        else
            if [[ -n "$until_epoch" ]]; then
                awk -v s="$since_epoch" -v e="$until_epoch" '$1>=s && $1<e' "$CACHE_FILE" | sort -n
            else
                awk -v s="$since_epoch" '$1>=s' "$CACHE_FILE" | sort -n
            fi
        fi
        return
    fi

    # ---- Predefined ranges & counts ----
    case "$arg" in
        '')
            if [[ $count_mode -eq 1 ]]; then
                awk '{count[strftime("%Y-%m-%d",$1)]++} END{for(d in count) printf "%s  %d\n", d, count[d]}' "$CACHE_FILE" | sort
            else
                sort -n "$CACHE_FILE"
            fi
            ;;

        today)
            if [[ $count_mode -eq 1 ]]; then
                awk -v s="$today_start" -v e="$tomorrow_start" '$1>=s && $1<e {count[strftime("%Y-%m-%d",$1)]++} END{for(d in count) printf "%s  %d\n", d, count[d]}' "$CACHE_FILE" | sort
            else
                awk -v s="$today_start" -v e="$tomorrow_start" '$1>=s && $1<e' "$CACHE_FILE" | sort -n
            fi
            ;;

        yesterday)
            if [[ $count_mode -eq 1 ]]; then
                awk -v s="$yesterday_start" -v e="$today_start" '$1>=s && $1<e {count[strftime("%Y-%m-%d",$1)]++} END{for(d in count) printf "%s  %d\n", d, count[d]}' "$CACHE_FILE" | sort
            else
                awk -v s="$yesterday_start" -v e="$today_start" '$1>=s && $1<e' "$CACHE_FILE" | sort -n
            fi
            ;;

        last-week)
            if [[ $count_mode -eq 1 ]]; then
                awk -v s="$last_week_start" '$1>=s {count[strftime("%Y-%m-%d",$1)]++} END{for(d in count) printf "%s  %d\n", d, count[d]}' "$CACHE_FILE" | sort
            else
                awk -v s="$last_week_start" '$1>=s' "$CACHE_FILE" | sort -n
            fi
            ;;

        this-month)
            if [[ $count_mode -eq 1 ]]; then
                awk -v s="$this_month_start" '$1>=s {count[strftime("%Y-%m-%d",$1)]++} END{for(d in count) printf "%s  %d\n", d, count[d]}' "$CACHE_FILE" | sort
            else
                awk -v s="$this_month_start" '$1>=s' "$CACHE_FILE" | sort -n
            fi
            ;;

        last-month)
            if [[ $count_mode -eq 1 ]]; then
                awk -v s="$last_month_start" -v e="$this_month_start" '$1>=s && $1<e {count[strftime("%Y-%m-%d",$1)]++} END{for(d in count) printf "%s  %d\n", d, count[d]}' "$CACHE_FILE" | sort
            else
                awk -v s="$last_month_start" -v e="$this_month_start" '$1>=s && $1<e' "$CACHE_FILE" | sort -n
            fi
            ;;

        per-day)
            awk '{count[strftime("%Y-%m-%d",$1)]++} END{for(d in count) printf "%s  %d\n", d, count[d]}' "$CACHE_FILE" | sort
            ;;

        per-week)
            awk '{count[strftime("%Y-W%V",$1)]++} END{for(w in count) printf "%s  %d\n", w, count[w]}' "$CACHE_FILE" | sort
            ;;

        *)
            echo "❌ Invalid option: '$arg'"
            echo "Run 'rpm-installed --help' for usage."
            return 1
            ;;
    esac
}

# If script is executed directly (not sourced), run the function
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    rpm-installed "$@"
fi
